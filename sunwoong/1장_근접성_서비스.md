근접성 서비스는 음식점, 호텔, 극장, 박물관 등 현재 위치에서 가까운 시설을 찾는 데 이용된다.

### 1단계. 문제 이해 및 설계 범위 확정

**기능 요구사항**

- 사용자의 위치(경도, 위도)와 검색 반경 정보에 매치되는 사업장 목록 반환
- 사업장 소유주가 사업장 정보를 추가, 삭제, 갱신할 수 있도록 한다. 단, 검색 결과에 실시간 반영은 X
- 고객은 사업장의 상세 정보를 볼 수 있음

**비기능 요구사항**

- 낮은 응답 지연
- 데이터 보호
    - 사용자 위치는 민감한 정보. 위치 기반 서비스(LBS) 설계 시 필수적으로 고려해야 함. GDPR, CCPA 같은 데이터 사생활 보호 범안을 준수하도록 해야 함.
- 고가용성 & 규모 확장성
    - 인구 밀집 지역에서 이용자가 집중되는 시간에 트래픽이 급증해도 감당할 수 있도록 설계

**개략적 규모 추정**

- DAU는 1억 명, 등록된 사업장 수는 2억
- 한 사용자가 하루 평균 5회 검색 시도한다 가정, QPS는 5,000

### 2단계. 개략적 설계안 제시 및 동의 구하기

**<API 설계>**

**주변 사업장 검색 API**

특정 검색 기준에 맞는 사업장 목록을 반환한다. 페이징으로 성능 최적화 가능

GET /v1/search/nearby

요청 파라미터

- latitude: 검색할 위도, type: decimal
- longitude: 검색할 경도, type: decimal
- radius: 선택적 인자. 기본값은 0.5km, type: int

```json
{
		"total": 10,
		"businesses": [{business object}]
}
```

- business object
    - 사업장을 표현하는 객체이며 검색 결과 페이지에 표시될 모든 정보를 포함한다.

**<사업장 관련 API>**

사업장 관련 CRUD API

**<데이터 모델>**

**읽기/쓰기 비율**

- 주변 사업장 검색
- 사업장 정보 확인

위의 두 가지 기능의 이용 빈도가 높기 때문에 읽기 연산은 자주 수행된다. 그러나 쓰기 연산의 실행 빈도는 낮다. 사업장 정보를 추가, 삭제, 수정하는 행위는 빈번하지 않기 때문이다.

읽기 연산이 압도적인 시스템에서는 MySQL 같은 관계형 데이터베이스가 바람직할 수 있다.

**데이터 스키마**

시스템의 핵심이 되는 테이블은 business 테이블과 지리적 위치 색인 테이블이다.

**business 테이블**

사업장 상세 정보를 담는다. 기본 키는 business_id

**지리적 위치 색인 테이블**

위치 정보 관련 연산의 효율성을 높이는 데 쓰인다.

**<개략적 설계>**

시스템은 위치 기반 서비스(LBS)와 사업장 관련 서비스 두 부분으로 구성된다.

**로드 밸런서**

유입 트래픽을 자동으로 여러 서비스에 분산시키는 컴포넌트. 통상적으로 단일 DNS 진입점을 지정하고 URL 경로를 분석하여 어느 서비스에 트래픽을 전달할지 결정한다.

**위치 기반 서비스(LBS)**

LBS는 시스템의 핵심으로 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색한다.

- 쓰기 요청이 없는 읽기 요청만 빈번하게 발생하는 서비스
- QPS가 높다. 특히 특정 시간대의 인구 밀집 지역일수록 그 경향이 심함
- 무상태 서비스이므로 Scale-Out이 용이함

**사업장 서비스**

- 사업장 소유주가 사업장 정보를 생성, 갱신, 삭제함. 기본적으로 쓰기 요청이며 QPS는 높지 않음

**데이터베이스 클러스터**

데이터베이스 클러스터는 주-부 데이터베이스 형태로 구성할 수 있다. 데이터는 주 데이터베이스에 기록된 후 사본 데이터베이스로 복사된다.

**사업장 서비스와 LBS의 규모 확장성**

사업장 서비스와 LBS는 둘 다 무상태 서비스. 따라서 집중적으로 몰리는 트래픽은 오토스케일링으로 대응하고 유휴 시간대에는 서버를 삭제하도록 구성할 수 있다. 또한, 시스템을 클라우드에서 서비스한다면 지역, 가용성 구역에 따라 서버를 두어 가용성을 높일 수 있다.

**주변 사업장 검색 알고리즘**

많은 회사가 레디스 지오해시 또는 PostGIS 확장을 설치한 Postgres 데이터베이스를 활용함.

**방안 1. 2차원 검색**

주어진 반경으로 그린 원 안에 놓인 사업장을 검색하는 방법.

- 테이블을 전부 읽어야 하므로 효율 X
- 위도, 경도에 색인을 만들어도 많은 성능 최적화는 어려움

**데이터베이스 색인으로는 오직 한 차원의 검색 속도만 개선할 수 있다는 문제가 존재한다. 그러면 어떻게 2차원 데이터를 한 차원에 대응시킬 수 있을까?**

먼저 지리적 정보에 색인을 만드는 방법을 알아보자.

- 해시 기반: 균등 격자, 지오해시, 카르테시안 계층 등
- 트리 기반: 쿼드트리, 구글 S2, R 트리 등

각 색인법의 구현 방법은 서로 다르지만 개략적 아이디어는 같다. 즉, 지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 색인을 만드는 것이다. 이 가운데 지오해시, 쿼드트리, 구글 S2는 실제로 가장 널리 사용되는 방안이다.

**방안 2. 균등 격자**

지도를 작은 격자 또는 구획으로 나누는 단순한 접근법. 하나의 격자는 여러 사업장을 담을 수 있고, 하나의 사업장은 오직 한 격자에만 속하게 된다.

- 사업장 분포가 균등하지 않다는 문제점 존재
- 주어진 격자의 인접 격자를 찾기 까다로울 수 있음

**방안 3. 지오해시**

균등 격자보다 나은 방안. 지오해시는 2차원의 위도 경도 데이터를 1차원 문자열로 변환한다. 비트를 하나씩 늘려가면서 재귀적으로 세계를 더 작은 격자로 분할해 나가는 알고리즘이다.

전세계를 본초 자오선과 적도 기준 사분면으로 나눈 후 아래 기준에 맞게 비트를 대응한다.

- 위도 범위 [-90, 0] → 0
- 위도 범위 [0, 90] → 1
- 경도 범위 [-180, 0] → 0
- 경도 범위 [0, 180] → 1

원하는 요구사항에 맞는 정밀도를 얻을 때까지 재귀적으로 반복하며 통상적으로 base32 표현법을 사용한다.

- 구글 본사 지오해시 (길이 = 6)
    - 1001 10110 01001 10000 11011 11010 → 9q9hvu

12단계의 정밀도를 가지며 이 정밀도가 격자 크기를 결정한다.

사용자가 지정한 반경으로 그린 원을 덮는 최소 크기 격자를 만드는 지오해시 길이를 구하면 최적 정밀도를 정할 수 있다.

단, 격자 가장자리 처리 방식에 관한 경계 조건이 몇 가지 있다.

- 해시값의 공통 접두어가 긴 격자들이 서로 더 가깝게 놓이도록 보장한다. 그러나 그 역은 참이 아니다. 즉, 아주 가까운 두 위치가 어떤 공통 접두어도 갖지 않는 경우가 생길 수 있다. 따라서 단순한 접두어 기반 쿼리로는 주변 모든 사업장을 가져올 수 없다.
- 두 지점이 공통 접두어 길이는 길지만 서로 다른 격자에 놓일 수 있다. 현재 격자를 비롯한 인접한 모든 격자의 모든 사업장 정보를 가져와 해결할 수 있다.

**만약, 표시할 작업장이 충분하지 않은 경우는?**

- 주어진 반경 내 사업장만 반환한다. 그러나 사용자의 니즈를 만족하기 충분한 수의 사업장 정보를 반환하지 못한다.
- 검색 반경을 키운다. 해시값의 마지막 비트를 삭제하여 얻은 새 해시값을 사용해 주변 사업장을 검색한다. 이를 반복해서 원하는 수 이상의 사업장을 얻을 때까지 격자 크기를 확장한다.

**방안 4. 쿼드트리**

격자의 내용이 특정 기준을 만족할 때까지 2차원 공간을 재귀적으로 사분면 분할하는 데 흔히 사용되는 자료구조다.

결국 질의에 답하는 데 사용될 트리 구조를 메모리 안에 만드는 것이 쿼드트리를 사용하는 것이다. 쿼드트리는 메모리 안에 놓이는 자료구조일 뿐, 데이터베이스는 아니다.

각각의 LBS 서버에 존재해야 하며, 서버가 시작하는 시점에 구축됨.

**쿼드트리 전부를 저장하는데 얼마나 많은 메모리가 필요한가?**

쿼드트리 인덱스가 메모리를 많이 필요로하지 않기 때문에 서버 한 대로 운영이 가능하나 읽기 연산 양이 많아지면 이에 따른 대응이 필요할 수 있다.

**전체 쿼드트리 구축에 소요되는 시간은?**

200만개의 사업장 정보를 인덱싱하는 쿼드트리 구축에 몇 분 정도 소요될 수 있다.

**쿼드트리로 주변 사업장을 검색하려면?**

1. 메모리에 쿼드트리 인덱스를 구축
2. 검색 시작점이 포함된 말단 노드를 만날 때까지, 트리의 루트 노드부터 탐색한다. 만약, 말단 노드에 충분한 사업장이 없는 경우, 충분한 사업장 수가 확보될 때까지 인접 노드로 추가한다.

**쿼드트리 운영 시 고려사항?**

- 서버 시작 시 트리를 구축하면 서버 시작 시간이 길어질 수 있다는 점을 중요하게 고려해야 한다. 쿼드트리를 구축 중인 서버는 트래픽을 처리할 수 없기 때문이다. 따라서 새로운 버전의 서버를 릴리즈할 때는 동시에 너무 많은 서버에 배포하지 않도록 조심해야 한다. 서버 클러스터의 상당 부분이 동시에 꺼져서 서비스 품질이 저하되는 일을 방지하기 위함이다. blue/green 배포 방안을 도입하는 경우, 시스템에 큰 부하가 가해질 수 있다는 점을 유의해야 한다.
- 사업장이 추가/삭제 되었을 때 쿼드트리를 갱신하는 문제이다. 가장 쉽게는 점신적으로 갱신하는 방법이다. 짧은 시간 동안 낡은 데이터가 반환될 수 있지만 요구사항이 엄격하지 않다면 도입할만 하다. 쿼드트리를 실시간으로 갱신할 수도 있지만 다중 스레드가 동시 접근하는 경우 동기화 문제를 해결해야 하므로 설계가 복잡해진다.

**방안 5. 구글 S2**

메모리 기반이며 지구를 힐베르트 곡선이라는 공간 채움 곡선을 사용하여 1차원 색인화하는 방안이다. 힐베르트 곡선의 가장 유명한 특징은 힐베르트 곡선 상에서 인접한 두 지점은 색인화 이후 1차원 공간 내에서도 인접한 위치에 있다는 것이다.

- 임의 지역에 다양한 수준의 영역 지정이 가능해서 지오펜스 구현에 장점을 가진다.
    - 지오펜스? → 실세계 지리적 영역에 설정한 가상의 경계
    - 경계 벗어난 경우 알림 전송 등 풍부한 기능을 제공할 수 있다.
- S2가 제공하는 영역 지정 알고리즘은 지오해시처럼 고정된 정밀도를 사용하는 대신 최소 수준, 최고 수준, 최대 셀 개수 등을 지정할 수 있다. 셀 크기를 유연하게 조정할 수 있기 때문에 좀 더 상세한 결과 반환이 가능하다.

**지오해시 vs 쿼드트리**

지오해시

- 구현과 사용이 쉬움. 트리 구축 필요 X
- 지정 반경 이내 사업장 검색을 지원
- 정밀도를 고정하면 격자 크기도 고정. 인구 밀도에 따라 동적으로 격자 크기를 조정할 수는 없음.
- 색인 갱신이 용이함. ex) 해시값과 사업장 식별자가 같은 레코드 하나만 제거하면 됨.

쿼드트리

- 구현하기 살짝 까다로움
- k번째로 가까운 사업장까지의 목록을 구할 수 있음. k개의 사업장을 찾을 때까지 검색 범위를 자동으로 조정할 수 있기 때문이다.
- 인구 밀도에 따라 격자 크기를 동적으로 조정할 수 있음.
- 색인 갱신이 까다롭다. 삭제를 위해 루트 노드부터 말단 노드까지 트리를 순회해야 함. 따라서 색인 갱신 시간복잡도는 O(logN)이다. 또한, 다중 스레드를 지원하려면 동기화 문제를 예방하기 위해 복잡한 설계가 필요하고 균형을 맞추기 위해 리밸런싱이 필요하다면 더욱 복잡해짐.

### 3단계. 상세 설계

**<데이터베이스의 규모 확장성>**

**사업장 테이블**

사업장 테이블 데이터는 한 서버에 담을 수 없을 수도 있다. 따라서 샤딩을 적용하기 좋은 후보이다. 가장 간단하게는 사업장 ID를 기준으로 샤딩할 수 있다.

**지리 정보 색인 테이블**

지오해시를 사용한다고 가정.

방안 1. 각각의 지오해시에 연결되는 모든 사업장 ID를 jSON 배열로 만들어 같은 열에 저장함. 즉, 특정 지오해시에 속한 모든 사업장 ID가 한 열에 보관됨.

방안 2. 같은 지오해시에 속한 사업장 ID 각각을 별도 열에 저장하는 방안. 즉, 사업장마다 한 개의 레코드가 필요함.

시간복잡도와 다중 스레드 환경을 고려하여 책에서는 방안 2를 추천한다.

**지리 정보 색인의 규모 확장**

테이블에 보관되는 데이터의 실제 크기를 고려하여 샤딩 도입 여부를 결정해야 한다. 관계형 데이터베이스의 경우 부하 분산을 위해 복제, 샤딩 방안을 적용할 수 있다.

애플리케이션 계층에서 샤딩 로직을 구현해야 하기 때문에 지오해시 테이블은 샤딩이 까다롭다. 그러나 샤딩이 유일한 선택지일 수 있다. 데이터를 서버 한 대에 저장할 수 있기 때문에 책에선 복제 방안을 선택했다.

**캐시**

캐시를 도입하기 전, 정말 필요한지 꼭 고민해봐야 한다. 좋은 결과로 이어지리라는 결론을 쉽게 내리기 어렵기 때문이다.

**캐시 키**

가장 직관적인 캐시 키는 사용자 위치의 위도 경도 정보이다. 그러나 다음과 같은 문제가 있다.

- 추정치일 뿐 아주 정확한 위치 정보는 아니다. 즉, 유동성이 강하다.
- 이동 시, 미세하게 데이터가 변경되지만 대부분의 애플리케이션에 이 변화는 의미가 없다.

따라서 캐시 키로 적절치 않으며 위치가 조금 달라지더라도 변화가 없어야 이상적이며 지오해시나 쿼드트리는 이 문제를 효과적으로 해결한다. 같은 격자 내 모든 사업장이 같은 해시 값을 갖도록 만들 수 있기 때문이다.

**캐시 데이터 유형**

| 키 | 값 |
| --- | --- |
| 지오해시 | 해당 격자 내의 사업장 ID 목록 |
| 사업장 ID | 사업장 정보 객체 |

위의 데이터를 캐시에 보관하면 시스템의 성능을 전반적으로 향상시킬 수 있음.

1. 주어진 지오해시에 대응되는 사업장 목록을 쿼리 질의를 통해 가져온다.
2. 주어진 지오해시에 대응되는 사업장 목록을 캐시를 통해 먼저 조회한다. 만약 없다면, 1번 과정을 수행하고 가져온 데이터를 캐시에 보관한다.

고가용성을 보장하고 대륙 경계를 넘는 트래픽의 전송지연을 방지하기 위해 레디스 클러스터를 전 세계에 각 지역별로 두고 동일한 데이터를 각 지역에 중복해서 저장해 두어야 함.

**지역 및 가용성 구역**

여러 지역과 가용성 구역에 설치한다.

- 사용자와 시스템 간의 물리적 거리를 최소화
- 트래픽을 인구에 따라 고르게 분산하는 유연성을 확보
- 지역의 사생활 보호법에 맞는 운영이 가능
    - 특정 국가는 해당 국가 이외의 지역으로 사용자 데이터를 전송하지 못하도록 규제한다.

**<최종 설계도>**

**주변 사업장 검색**

1. 주변 반경 0.5km 내 모든 식당을 찾는 경우를 가정한다. 사용자는 자신의 위치(위도, 경도)와 검색 반경을 로드밸런서로 전송
2. 로드밸런서는 해당 요청을 LBS로 전달
3. 주어진 데이터에 따라 LBS는 검색 요건을 만족할 지오해시 길이를 구함
4. LBS는 인접한 지오해시를 계산한 다음 목록에 추가
    1. geohashes = [my_geohash, neighbor1_geohash, neighbor2_geohash …]
5. 목록의 각각에 대해 LBS는 지오해시 데이터를 저장하고 있는 캐시 서버를 통해 해당 지오해시에 대응하는 모든 사업장 ID를 가져옴. 이때, 병렬 처리하면 검색 결과를 내는 지연시간을 줄일 수 있음.
6. 가져온 사업장 ID들을 가지고 사업장 정보 데이터를 저장하고 있는 캐시 서버를 통해 각 사업장의 상세 정보를 가져옴. 이후 사용자와 사업장 간의 거리를 정확하게 계산하고 우선순위를 매핑한 이후 사용자에게 반환

**사업장 정보 조회, 갱신, 추가, 삭제**

사업장 정보 서비스는 데이터가 사업장 정보 데이터를 저장하고 있는 캐시 서버에 저장되어 있는지 확인한다. 캐시되어 있는 경우 해당 데이터를 읽어 사용자에게 반환. 그렇지 않은 경우 데이터베이스 클러스터에서 사업장 정보를 읽어 캐시에 저장한 다음 반환한다.