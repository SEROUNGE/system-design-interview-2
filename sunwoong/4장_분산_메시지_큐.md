### 메시지 큐를 사용하면 얻을 수 있는 이점

---

- 결합도 완화
    - 컴포넌트 사이 강한 결합이 사라지므로 각각을 독립적으로 갱신할 수 있다.
- 규모 확장성 개선
    - 생산자, 소비자 시스템 규모를 트래픽 부하에 맞게 독립적으로 늘릴 수 있다.
- 가용성 개선
    - 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 계속 상호작용을 이어갈 수 있다.
- 성능 개선
    - 메시지 큐를 사용하면 비동기 통신이 쉽게 가능하다.

### 1단계. 문제 이해 및 설계 범위 확정

---

**기능 요구사항**

- 생산자는 메시지 큐에 메시지를 전송
- 소비자는 메시지 큐를 통해 메시지를 수신
- 메시지는 반복 수신 가능, 단 한 번만 수신하도록 설정 가능
- 오래된 이력 데이터는 삭제 가능
- 메시지 크기는 KB 수준
- 메시지가 생산된 순서대로 소비자에게 전달할 수 있음
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정 가능

**비기능 요구사항**

- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정으로 선택 가능
- 규모 확장성
- 지속성 및 내구성

### 2단계. 개략적 설계안 제시 및 동의 구하기

---

**메시지 큐의 기본 기능**

- 생산자는 메시지를 큐에 발행
- 소비자는 큐를 구독하고 구독한 메시지를 소비
- 큐는 생산자와 소비자 사이의 결합을 느슨하게 하는 서비스로, 각각 독립적인 운영 및 규모 확장을 가능하게 하는 역할을 담당

### **메시지 모델**

---

**일대일 모델**

큐에 전송된 메시지는 오직 한 소비자만 가져갈 수 있는 모델. 어떤 소비자가 메시지를 가져갔다는 사실을 큐에 알리면 해당 메시지는 큐에서 삭제. 데이터 보관을 지원하지 않음.

**발행-구독 모델**

토픽 개념을 도입해야 하며 토픽은 메시지를 주제별로 정리하는 데 사용됨. 각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 가진다.

메시지를 보내고 받을 때는 토픽에 보내고 받게 되며 토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에 전달된다.

본 설계안의 분산 메시지 큐는 두 가지 모델을 모두 지원한다. 발행-구독 모델은 토픽을 통해 구현할 수 있고, 일대일 모델은 소비자 그룹을 통해 지원할 수 있다.

**토픽, 파티션, 브로커**

메시지는 토픽에 보관된다. 토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당하기 힘든 상황이 벌어지면 어떻게 될까?

파티션 즉, 샤딩을 활용할 수 있다. 토픽을 여러 파티션으로 분할한 다음에 메시지를 모든 파티션에 균등하게 나눠 보낸다.

파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치한다.

파티션을 유지하는 서버는 보통 브로커라 부른다.

파티션을 브로커에 분산하는 것이 높은 규모 확장성을 달성할 수 있는 방법이며 토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 된다.

각 토픽 파티션은 FIFO 큐처럼 동작한다. 즉, 같은 파티션 안에서는 메시지 순서가 유지된다. 또한, 파티션 내에서의 메시지 위치는 오프셋이라 한다.

생산자가 보낸 메시지는 해당 토픽의 파티션 가운데 하나로 보내진다. 메시지에는 사용자 ID 같은 키를 붙일 수 있는데, 같은 키를 가진 모든 메시지는 같은 파티션으로 보내진다. 반면에 키가 없는 메시지는 무작위로 선택된 파티션으로 전송된다.

토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져오게 된다. 토픽을 구독하는 소비자가 여럿인 경우, 각 구독자는 해당 토픽을 구성하는 파티션의 일부를 담당하게 되며 해당 토픽의 소비자 그룹이라 부른다.

**소비자 그룹**

소비자 그룹 내 소비자는 토픽에서 메시지를 소비하기 위해 서로 협력한다. 하나의 소비자 그룹은 여러 토픽을 구독할 수 있고 오프셋을 별도로 관리한다.

같은 그룹 내의 소비자는 메시지를 병렬로 소비할 수 있다. 단, 데이터를 병렬로 읽으면 대역폭 측면에서는 좋지만 같은 파티션 안에 있는 메시지를 순서대로 소비할 수는 없다. 그러나 어떤 파티션의 메시지는 한 그룹 안에서는 오직 한 소비자만 읽을 수 있도록 하면 문제를 해결할 수 있다. 하지만 그룹 내 소비자의 수가 구독하는 토픽의 파티션 수보다 크면 어떤 소비자는 해당 토픽에서 데이터를 읽지 못하게 된다.

### 3단계. 상세 설계

---

데이터의 장기 보관 요구사항을 만족하면서 높은 대역폭을 제공하기 위해 세 가지 중요한 결정을 내렸다.

- 회전 디스크의 높은 순차 탐색 성능과 현대적 운영체제가 제공하는 적극적 디스크 캐시 전략을 이용하는 디스크 기반 자료구조 활용
- 메시지가 생산자로부터 소비자에게 전달되는 순간까지 아무 수정 없이도 전송이 가능하도록 하는 메시지 자료구조를 설계 및 활용
- 일괄 처리를 우선하는 시스템 설계. 소규모의 I/O가 많으면 높은 대역폭을 지원하기 어렵다. 따라서 본 설계안은 일괄 처리를 장려

**데이터 저장소**

메시지 큐의 트래픽 패턴

- 읽기, 쓰기 빈번함
- 갱신, 삭제 연산을 발생 X
- 순차적 읽기, 쓰기가 대부분

선택지 1. 데이터베이스

- 관계형 데이터베이스
    - 토픽별로 테이블을 만든다. 토픽에 보내는 메시지는 해당 테이블에 새로운 레코드로 추가한다.
- NoSQL 데이터베이스
    - 토픽별로 컬렉션을 만든다. 토픽에 보내는 메시지는 하나의 문서가 된다.

요구사항을 맞출 수는 있으나 이상적인 방법은 아니다. 읽기, 쓰기 연산이 동시에 대규모로 빈번하게 발생하는 상황을 잘 처리하는 데이터베이스는 설계하기 어려운 탓이다. 최선의 선택지가 될 수 없고 오히려 시스템 병목이 될 수 있다.

선택지 2. 쓰기 우선 로그(Write-Ahead Log, WAL)

WAL은 새로운 항목이 추가되기만 하는 일반 파일이다. 지속성을 보장해야 하는 메시지는 디스크에 WAL로 보관할 것을 추천한다. WAL에 대한 접근 패턴은 읽기, 쓰기 전부 순차적이다.

**일괄 처리**

생산자, 소비자, 메시지 큐는 메시지를 가급적 일괄 처리한다. 일괄 처리는 시스템 성능에 아주 중요하며 이유는 다음과 같다.

- OS로 하여금 여러 메시지를 한 번의 네트워크 요청으로 전송할 수 있도록 하기 때문에 값비싼 네트워크 왕복 비용을 제거할 수 있다.
- 브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산이 발생하고 OS가 관리하는 디스크 캐시에서 더 큰 규모의 연속된 공간을 점유하게 된다. 그 결과로 더 높은 디스크 접근 대역폭을 달성할 수 있다.

**생산자 측 작업 흐름**

생산자가 어떤 파티션에 메시지를 보내려고 할 때 어느 브로커에 연결돼야 할까? 라우팅 계층을 도입하여 해결할 수 있다.

라우팅 계층은 적절한 브로커에 메시지를 보내는 역할을 담당한다. 브로커를 여러 개로 복제하여 운용하는 경우에 메시지를 받을 적절한 브로커는 리더 브로커다.

1. 생산자는 메시지를 라우팅 계층에 보냄.
2. 라우팅 계층은 메타데이터 저장소에서 사본 분산 계획을 읽어 자기 캐시에 보관. 메시지가 도착하면 리더 사본에 보냄.
3. 리더 사본을 따르는 다른 사본들은 해당 리더로부터 데이터를 받음.
4. 충분한 수의 사본이 동기화되면 리더는 데이터를 디스크에 기록. 이때 소비 상태가 되며 생산자에게 회신을 보냄

리더와 사본이 필요한 이유? → 장애 감내

그러나 단점도 있다.

- 라우팅 계층을 추가적으로 거쳐야 해서 네트워크 전송 지연이 늘어남.
- 일괄 처리가 가능하면 효율을 많이 높일 수 있는데 고려되지 않음.

라우팅 계층을 생산자 내부로 편입시키고 버퍼를 도입하여 개선할 수 있다. 아래와 같은 장점이 생긴다.

- 네트워크를 거치지 않아도 되어 전송 지연이 감소함.
- 생산자는 메시지를 어느 파티션에 보낼지 결정하는 자신만의 로직을 가질 수 있음.
- 전송할 메시지를 버퍼 메모리에 보관했다가 목적지로 일괄 전송하여 대역폭 증가.

**소비자 측 작업 흐름**

소비자는 특정 파티션의 오프셋을 주고 해당 위치에서부터 이벤트를 묶어 가져온다.

푸시 vs 풀

브로커가 데이터를 소비자에게 보낼 것이냐 아니면 소비자가 브로커에서 가져갈 것이냐 하는 부분은 중요하게 따져봐야 한다.

푸시 모델

장점 → 낮은 지연: 브로커는 메시지를 받는 즉시 소비자에게 보낼 수 있음.

단점 → 소비자 처리 속도 < 생산자 메시지 생성 속도 이면, 소비자에게 큰 부하가 걸릴 수 있음. 생산자가 데이터 전송 속도를 좌우하므로 소비자는 항상 그에 맞는 처리가 가능한 컴퓨팅 자원을 준비해 두어야 함.

풀 모델

장점 → 메시지 소비 속도는 소비자가 결정. 소비자 처리 속도 < 생산자 메시지 생성 속도여도 소비자를 늘려 해결할 수 있음. 일괄 처리에 적합함.

단점 → 소비자 측 컴퓨팅 자원 낭비. 이 문제를 해결하기 위해 롱 폴링 모드 지원.

대부분의 메시지 큐는 풀 모델을 지원함.

1. 그룹에 합류하고 토픽 A를 구독하길 원한다고 가정. 소비자는 그룹 이름 해싱으로 접속할 브로커 노드를 찾음. 따라서 같은 그룹의 모든 소비자는 같은 브로커에 접속. 이런 브로커를 해당 소비자 그룹의 코디네이터라 한다.
2. 코디네이터는 소비자를 그룹에 참여시키고 파티션을 해당 소비자에 할당.
3. 소비자는 마지막으로 소비한 오프셋 이후 메시지를 가져옴.
4. 소비자는 메시지를 처리하고 새로운 오프셋을 브로커에 보냄.

**소비자 재조정**

소비자 재조정은 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스다. 새로운 소비자 합류, 기존 소비자 그룹 떠남, 소비자 장애 발생, 파티션 조정되는 경우들에 시작될 수 있다.

코디네이터는 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드다. 소비자로부터 오는 박동 메시지를 살피고 각 소비자의 파티션 내 오프셋 정보를 관리한다.

- 같은 그룹의 모든 소비자는 같은 코디네이터에 연결
- 코디네이터는 자신에 연결한 소비자 목록을 유지. 변화가 생기면 해당 그룹의 새 리더 선출
- 새 리더는 새 파티션 배치 계획을 만들고 코디네이터에게 전달.

**상태 저장소**

- 소비자에 대한 파티션의 배치 관계
- 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋

위의 두 가지 데이터를 저장한다.

**메타데이터 저장소**

토픽 설정이나 속성 정보를 보관한다. 파티션 수, 메시지 보관 기간, 사본 배치 정보 등이 이에 해당한다. 자주 변경되지 않으며 양도 적다. 하지만 높은 일관성을 요구한다.

**복제**

높은 가용성을 보장하기 위해 전통적으로 많이 사용된 방법은 복제다.

각 파티션은 3개의 사본을 갖고 이 사본들은 서로 다른 브로커 노드에 분산되어 있다. 짙은 색 사본은 해당 파티션의 리더이고 생산자는 파티션에 메시지를 보낼 때 리더에게만 보낸다. 다른 사본은 리더에서 새 메시지를 지속적으로 가져와 동기화한다. 메시지가 완전히 동기화한 사본의 개수가 지정된 임계값을 넘으면 리더는 생산자에게 메시지를 잘 받았다는 응답을 보낸다.

사본을 파티션에 어떻게 분산할지 기술하는 것을 사본 분산 계획이라 하며 조정 서비스의 도움으로 리더 브로커 노드가 선출되면 해당 노드가 만들어 메타데이터 저장소에 보관한다.

**사본 동기화**

그래서 어떻게 사본을 동기화 해야 하는 걸까?

동기화된 사본(ISR)은 리더와 동기화된 사본을 일컫는 용어다. 합의 오프셋은 오프셋 이전에 기록된 모든 메시지는 이미 ISR 집합 내 모든 사본에 동기화가 끝났다는 것을 의미한다. ISR은 성능과 영속성 사이의 타협점이며 이를 활용해서 메시지 수신 응답을 설정한다.

ACK = all

생산자는 모든 ISR이 메시지를 수신한 뒤에 ACK 응답을 받는다. 메시지의 영속성을 가장 좋지만 응답 시간이 지연된다.

ACK = 1

생산자는 리더가 메시지를 저장하고 나면 바로 ACK 응답을 받는다. 응답 지연은 개선되나 리더에 장애가 생기면 복구할 길 없이 소실된다. 데이터가 사라져도 상관없는 대신 낮은 응답 지연을 보장해야 하는 시스템에 적합하다.

ACK = 0

보낸 메시지에 대한 수신 확인 메시지를 기다리지 않고 재시도도 하지 않는다. 낮은 응답 지연을 달성하기 위해 메시지 손실은 감수하는 구성이다. 지표 수집이나 데이터 로깅 등 처리해야 하는 메시지의 양이 많고 때로 데이터 손실이 발생해도 상관 없는 경우에 좋다.

**규모 확장성**

생산자

새로운 생산자를 추가하거나 삭제한다.

소비자

소비자 그룹은 서로 독립적이므로 새 소비자 그룹을 추가하고 삭제한다. 같은 소비자 그룹 내의 소비자가 새로 추가, 삭제 되거나 장애로 제거되어야 하는 경우는 재조정 메커니즘이 맡아 처리한다.

브로커

브로커의 결함 내성

- 메시지가 성공적으로 합의 되었다고 판단하려면 얼마나 많은 사본에 메시지가 반영되어야 하는가?
    - 응답 지연과 안전성 사이의 균형을 찾아야 한다.
- 모든 사본이 같은 브로커 노드에 있으면 장애 발생 시 해당 파티션은 완전 소실될 것이다. 따라서 사본은 같은 노드에 두지 않는다.
- 파티션의 모든 사본에 문제가 생기면 해당 파티션의 데이터는 영원히 사라진다. 데이터 안전성, 자원 유지에 드는 비용, 응답 지연등을 고려해서 여러 데이터 센터에 분산하는 것이 안전하다.

브로커 노드가 추가되거나 삭제될 때마다 사본을 재배치할 수도 있지만 브로커 컨트롤러로 하여금 한시적으로 시스템에 설정된 사본 수보다 많은 사본을 허용하도록 하여 규모 확장성을 지원할 수 있다.

**파티션**

파티션의 수가 달라지면 데이터 저장 계층에 아래와 같은 일들이 일어난다.

파티션 추가

- 지속적으로 보관된 메시지는 여전히 기존 파티션에 존재하며 해당 데이터는 이동하지 않는다.
- 새로운 파티션이 추가되면 그 이후 오는 메시지는 3개 파티션 전부에 지속적으로 보관되어야 한다.

파티션 삭제

- 새로운 메시지는 삭제 예정 파티션외의 다른 파티션에만 보관된다.
- 삭제된 파티션은 일정 시간 동안 유지한다. 해당 파티션의 데이터를 읽고 있는 소비자가 있을 수 있기 때문이다.
- 실제로 파티션이 삭제되면 생산자 그룹은 재조정 작업을 개시해야 한다.

**메시지 전달 방식**

최대 한 번

메시지가 전달 과정에서 소실되더라도 다시 전달되는 일은 없다.

- 생산자는 토픽에 비동기적으로 메시지를 보내고 수신 응답을 기다리지 않는다. 메시지 전달이 실패해도 재시도 X
- 소비자는 메시지를 읽고 처리하기 전에 오프셋부터 갱신한다. 오프셋이 갱신된 직후에 소비자가 장애로 죽으면 메시지는 다시 소비될 수 없다.

지표 모니터링 등 소량의 데이터 손실을 감수할 수 있는 경우에 적합하다.

최소 한 번

메시지가 한 번 이상 전달될 수 있으나 메시지 소실은 발생하지 않는 전달 방식이다.

- 생산자는 메시지를 동기적/비동기적으로 보낼 수 있으며 ACK = 1 또는 ACK = all을 활용한다. 즉, 메시지가 브로커에게 전달되었음을 반드시 확인한다. 만약, 실패 or 타임아웃 시 재시도 메커니즘이 동작한다.
- 소비자는 데이터를 성공적으로 처리한 뒤에만 오프셋을 갱신한다. 메시지 처리가 실패한 경우, 메시지를 다시 가져오므로 데이터가 손실되는 일은 없다. 단, 오프셋 갱신 전에 소비자가 재시작되면 메시지가 중복 처리 될 수 있다.

메시지 소실은 없지만 중복 전송될 수 있다. 이는 애플리케이션 레벨에서 제어가 가능하므로 충분히 괜찮은 전송 방식이다.

정확히 한 번

사용자 입장에서는 편리하지만, 시스템의 성능 및 구현 복잡도 측면에서는 큰 대가를 지불해야 한다. 지불, 매매, 회계 등 금융 관련 응용에는 이 전송 방식이 적합하다. 중복을 허용하지 않으며, 구현에 이용할 서비스나 제3자 제품이 같은 입력에 항상 같은 결과를 내 놓도록 구현되어 있지 않은 애플리케이션에 특히 중요한 전송 방식이다.

### 고급 기능

---

**메시지 필터링**

토픽은 같은 유형의 메시지를 담아 처리하기 위해 도입된 논리적 개념이다. 하지만 어떤 소비자 그룹은 그 가운데서도 특정한 세부/하위 유형의 메시지에만 관심이 있다.

예를 들어 주문 시스템은 토픽에 주문과 관련된 모든 활동을 전송할 터이지만 지불 시스템은 그 가운데 결재나 환불 관련 메시지에만 관심이 있을 것이다.

이런 요구사항을 처리하는 한 가지 방법은 지불 시스템 전용 토픽을 주문 시스템 토픽과 분리하는 것이지만 다음과 같은 우려가 있다.

- 다른 시스템에도 비슷한 필요가 있을 수 있는데, 그때마다 전용 토픽을 만들 것인가?
- 같은 메시지를 여러 토픽에 저장하는 것은 자원 낭비
- 새로운 소비자 측 요구사항이 등장할 때마다 생산자 구현을 변경해야 할 수 있다. 즉, 결합도가 높아짐

따라서 다른 접근법을 생각해야 하며 메시지 필터링을 사용하면 문제를 해결할 수 있다.

가장 쉬운 방법은 소비자가 모든 메시지를 수신한 후 필요 없는 메시지를 버리는 방법이다. 유연성은 높으나 불필요한 트래픽이 발생하여 시스템 성능이 저하되는 문제가 있을 것이다.

더 나은 방법은 브로커에서 메시지를 필터링하여 소비자는 원하는 메시지만 수신하도록 하는 방법이다. 필터링에 사용될 데이터는 메시지의 메타데이터 영역에 두어 브로커로 하여금 효율적으로 읽어갈 수 있도록 해야 한다. 예를 들어 태그 필드를 적용할 수 있다.

**메시지의 지연 전송 및 예약 전송**

예를 들어 주문을 넣은 후 30분 안에 결재가 이루어지지 않으면 해당 주문을 취소하고 싶다고 가정하자. 결재 완료 확인을 지시하는 메시지를 주문 시점에 바로 전송하되 큐 소비자에게는 30분 뒤에 전달되도록 해 두면 소비자는 메시지를 받았을 때 결재 여부만 확인하면 된다. 결재가 완료되지 않은 주문은 취소하면 될 것이고 그렇지 않은 경우에는 해당 메시지는 무시하면 될 것이다.

발송 즉시 전달되는 메시지와 달리 이런 메시지는 토픽에 바로 저장하지 않고 브로커 내부의 임시 저장소에 넣어 두었다가 시간이 되면 토픽으로 옮긴다.